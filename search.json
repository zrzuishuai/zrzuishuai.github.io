[{"title":"Apache 2.4.49","date":"2021-10-15T02:09:10.000Z","url":"/2021/10/15/Apache-2-4-49/","tags":[["Apache 2.4.49","/tags/Apache-2-4-49/"]],"categories":[["渗透","/categories/%E6%B8%97%E9%80%8F/"]],"content":"漏洞描述 Apache HTTPd是Apache基金会开源的一款流行的HTTP服务器。2021年10月8日Apache HTTPd官方发布安全更新，披露了CVE-2021-42013 Apache HTTPd 2.4.49/2.4.50 路径穿越漏洞。由于对CVE-2021-41773 Apache HTTPd 2.4.49 路径穿越漏洞的修复不完善，攻击者可构造恶意请求绕过补丁，利用穿越漏洞读取到Web目录之外的其他文件。同时若Apache HTTPd开启了cgi支持，攻击者可构造恶意请求执行命令，控制服务器。 影响版本 Apache HTTPd 2.4.49/2.4.50版本 验证过程 Apache HTTPd 2.4.49 任意文件读取漏洞验证： GET数据包： Apache HTTPd 2.4.49 命令执行测试，未能成功回显命令，回显了bash报错信息。 POST数据包： Apache HTTPd 2.4.50 命令执行测试： 一个图片总结这次ApacheHTTPd 2.4.50版本修复不完善。 修复建议 建议使用Apache HTTPd 2.4.49 与Apache HTTPd 2.4.50 版本的服务器更新Apache HTTPd 版本至最新。 检测工具 Apache 2.4.49 (CVE-2021-41773)Apache 2.4.50 (CVE-2021-42013)批量多线程检测工具：Github地址：  "},{"title":"Spring Boot Actuator未授权访问利用实战利用","date":"2021-09-17T10:39:53.000Z","url":"/2021/09/17/Spring%20Boot%20Actuator%E6%9C%AA%E6%8E%88%E6%9D%83%E8%AE%BF%E9%97%AE%E5%88%A9%E7%94%A8%E5%AE%9E%E6%88%98%E5%88%A9%E7%94%A8/","tags":[["Spring Boot","/tags/Spring-Boot/"]],"categories":[["渗透","/categories/%E6%B8%97%E9%80%8F/"]],"content":"Spring Boot 集合前言Actuator是spring boot提供的用来对应用系统进行自省和监控的功能模块，借助于Actuator开发者可以很方便地对应用系统某些监控指标进行查看、统计等。如果没有做好相关权限控制，非法用户可通过访问默认的执行器端点（endpoints）来获取应用系统中的监控信息。Actuator配置不当会导致未授权访问获取网站相关配置甚至RCE 版本Spring Cloud 是基于 Spring Boot 来进行构建服务，并提供如配置管理、服务注册与发现、智能路由等常见功能的帮助快速开发分布式系统的系列框架的有序集合 组件版本相互依赖关系 Spring Cloud 与 Spring Boot 版本之间的依赖关系 Spring Cloud 小版本号的后缀及含义 [TOC] 环境搭建环境准备：JDK 1.8 or later and Maven 3.2+ 漏洞环境集合源码 下面是网盘中的资源包对应的命令执行漏洞 修改监听端口(不修改的话默认只能在搭建环境主机上访问) 安装 启动服务(安装完成后会在主目录下生成后target文件夹，执行里面的jar包启动服务) 访问显示springboot欢迎页面 当访问错误页面时，会提示错误信息 这里访问env就可以看到环境特性 访问health显示应用的健康状态 漏洞集合1.信息泄露1.1.路由及接口调用详情泄露 开发人员没有意识到地址泄漏会导致安全隐患或者开发环境切换为线上生产环境时，相关人员没有更改配置文件，忘记切换环境配置等 可以访问以下swagger相关路由进行验证 一般来讲，暴露出 spring boot 应用的相关接口和传参信息并不能算是漏洞，但是以 “默认安全“ 来讲，不暴露出这些信息更加安全。 对于攻击者来讲，一般会仔细审计暴露出的接口以增加对业务系统的了解，并会同时检查应用系统是否存在未授权访问、越权等其他业务类型漏洞 还有一些内置的端点路由由于未设置actuator访问控制暴露 所有端点皆可以在org.springframework.boot.actuate.endpoint中找到表达的含义 其中对寻找漏洞比较重要接口的有： /env、/actuator/env GET 请求 /env 会直接泄露环境变量、内网地址、配置中的用户名等信息；当程序员的属性名命名不规范，例如 password 写成 psasword、pwd 时，会泄露密码明文； 同时有一定概率可以通过 POST 请求 /env 接口设置一些属性，间接触发相关 RCE 漏洞；同时有概率获得星号遮掩的密码、密钥等重要隐私信息的明文。 /refresh、/actuator/refresh POST 请求 /env 接口设置属性后，可同时配合 POST 请求 /refresh 接口刷新属性变量来触发相关 RCE 漏洞。 /restart、/actuator/restart 暴露出此接口的情况较少；可以配合 POST请求 /env 接口设置属性后，再 POST 请求 /restart 接口重启应用来触发相关 RCE 漏洞。 /jolokia、/actuator/jolokia 可以通过 /jolokia/list 接口寻找可以利用的 MBean，间接触发相关 RCE 漏洞、获得星号遮掩的重要隐私信息的明文等。 /trace、/actuator/httptrace 一些 http 请求包访问跟踪信息，有可能在其中发现内网应用系统的一些请求信息详情；以及有效用户或管理员的 cookie、jwt token 等信息。 除了上面一些端点路由，还有程序员自定义的根路径 /manage、/management、项目APP相关名称 修改内置端点名字(如有些时候/env被程序员修改为/appenv) 1.2.端点路由泄露导致敏感信息泄露认证字段的获取以证明可影响其他用户 这个主要通过访问/trace 路径获取用户认证字段信息，比如如下站点存在 actuator配置不当漏洞，在其 trace 路径下，除了记录有基本的 HTTP 请求信息（时间戳、HTTP头等），还有用户 token、cookie字段 trace 路径： 用户字段泄露: 通过替换 token 字段可获取其他用户的信息 数据库账户密码泄露 由于 actuator 会监控站点 mysql、mangodb之类的数据库服务，所以通过监控信息有时可以拿下 mysql、mangodb数据库；这个主要通过/env 路径获取这些服务的配置信息，比如如下站点存在 actuator配置不当漏洞，通过其/env 路径，可获得 mysql、mangodb 的用户名及密码： Gitlab源代码泄露 这个一般是在/health 路径，比如如下站点，访问其 health 路径可探测到站点 git项目地址： 后台用户账号密码泄露 这个一般是在/heapdump 路径下，访问/heapdump 路径，返回 GZip 压缩 hprof堆转储文件。在 Android studio打开，会泄露站点内存信息，很多时候会包含后台用户的账号密码，泄露账号密码 1.3获取星号脱敏的密码明文方法一 访问 /env 接口时，spring actuator 会将一些带有敏感关键词(如 password、secret)的属性名对应的属性值用 * 号替换达到脱敏的效果 利用条件 目标网站存在 /jolokia 或 /actuator/jolokia 接口 目标使用了 jolokia-core 依赖（版本要求暂未知） 利用过程步骤一:确定属性名 访问目标网站的/env或/actuator/env端点接口，全局搜索星号(*************)，通过被星号遮掩的属性值找到想要的目标属性 步骤二:jolokia 调用相关 Mbean 这里需要获取的属性名为security.user,password，直接发包可以在响应包中的value键值中看到 调用 org.springframework.boot Mbean 实际上是调用 org.springframework.boot.admin.SpringApplicationAdminMXBeanRegistrar 类实例的 getProperty 方法 spring 1.x spring 2.x 调用 org.springframework.cloud.context.environment Mbean 实际上是调用 org.springframework.cloud.context.environment.EnvironmentManager 类实例的 getProperty 方法 spring 1.x spring 2.x 调用其他 Mbean 目标具体情况和存在的 Mbean 可能不一样，可以搜索 getProperty 等关键词，寻找可以调用的方法。 方法二利用条件 可以 GET 请求目标网站的 /env 可以 POST 请求目标网站的 /env 可以 POST 请求目标网站的 /refresh 接口刷新配置（存在 spring-boot-starter-actuator 依赖） 目标使用了 spring-cloud-starter-netflix-eureka-client 依赖 目标可以请求攻击者的服务器（请求可出外网） 利用方法步骤一:确定属性名 访问目标网站的/env或/actuator/env端点接口，全局搜索星号(*************)，通过被星号遮掩的属性值找到想要的目标属性 步骤二： 使用 nc 监听 HTTP 请求 在自己控制的外网服务器上监听 80 端口： 步骤三： 触发对外 http 请求 eureka.client.serviceUrl.defaultZone=:$&#123;属性&#125;@your-vps-ip:port 属性替换为想要获取的目标属性 your-vps-ip 换成自己外网服务器的真实 ip 地址 port为前面监听的端口 eureka.client.serviceUrl.defaultZone 方法（不适用于明文数据中有特殊 url 字符的情况） spring 1.x spring 2.x spring.cloud.bootstrap.location 方法（同时适用于明文数据中有特殊 url 字符的情况） spring 1.x spring 2.x 步骤四： 刷新配置 spring 1.x spring 2.x 步骤五： 解码属性值 正常的话，此时 nc 监听的服务器会收到目标发来的请求，其中包含类似如下 Authorization 头内容： 将其中的 dmFsdWU6MTIzNDU2部分使用 base64 解码，即可获得类似明文值 value:123456，其中的 123456 即是目标星号 * 脱敏前的属性值明文。 方法三利用条件 可正常 GET 请求目标 /heapdump 或 /actuator/heapdump 接口 利用方法步骤一:确定属性名 访问目标网站的/env或/actuator/env端点接口，全局搜索星号(*************)，通过被星号遮掩的属性值找到想要的目标属性 步骤二:下载 jvm heap 信息 下载的 heapdump 文件大小通常在 50M—500M 之间，有时候也可能会大于 2G GET 请求目标的 /heapdump 或 /actuator/heapdump 接口，下载应用实时的 JVM 堆信息 步骤三:使用 MAT 获得 jvm heap 中的密码明文 参考 文章 方法，使用 Eclipse Memory Analyzer 工具的 OQL 语句 辅助用 “password“ 等关键词快速过滤分析，获得密码等相关敏感信息的明文。 2.命令执行2.1.whitelabel error page SpEL RCE利用条件 spring boot 1.1.0-1.1.12、1.2.0-1.2.7、1.3.0 至少知道一个触发 springboot 默认错误页面的接口及参数名 利用方法步骤一: 找到目标网站正常传参点 比如发现访问 /xxxx?id=xxx ，页面会报状态码为 500 的默认错误页面 步骤二: 确认漏洞点 输入 /xxxx?id=$&#123;运算表达式&#125; (假设运算表达式为7x7) 如果发现报错页面将 7x7 的值 49 计算出来并显示在报错页面上，那么基本可以确定目标存在 SpEL 表达式注入漏洞。 步骤三: 命令执行漏洞利用 运行代码将执行的命令字符串转换成 0x** java 字节形式(只需将target变量修改为需要执行的命令即可) 执行 open -a Calculator 命令 利用实例环境是上面的资源集合的springboot-spel-rce，环境搭建参照上方 在搭建过程中可能会出现启动jar包时提示没有主清单属性，需要在pom.xml文件中添加依赖完成(参照文章点击这里) 访问${7*7} 可以看到错误页面中花括号里面的表达式已经计算出来啦，49。此处参数点可利用 下面将花括号里面的修改成需要执行的命令 首先要将命令字符串转换为java字节形式，利用上面的python脚本 这里执行的命令为bash反弹shell，先将其进行base64编码转换(在线转换地址) 在将其转换为java字节 使用nc监听192.168.233.243的9090端口 将转换后的java字节拼接到payload中，在浏览器中访问 反弹shell成功 利用原理 spring boot 处理参数值出错，流程进入 org.springframework.util.PropertyPlaceholderHelper 类中 此时 URL 中的参数值会用 parseStringValue 方法进行递归解析 其中 $&#123;&#125; 包围的内容都会被 org.springframework.boot.autoconfigure.web.ErrorMvcAutoConfiguration 类的 resolvePlaceholder 方法当作 SpEL 表达式被解析执行，造成 RCE 漏洞 详细分析参见下文: ​ SpringBoot SpEL表达式注入漏洞-分析与复现 2.2Spring clound SnakeYAML RCE利用条件 可以 POST 请求目标网站的 /env 接口设置属性 可以 POST 请求目标网站的 /refresh 接口刷新配置（存在 spring-boot-starter-actuator 依赖） 目标依赖的 spring-cloud-starter 版本 &lt; 1.3.0.RELEASE 目标可以请求攻击者的 HTTP 服务器（请求可出外网） 利用方法步骤一: 托管yml和jar文件 首先在自己的机器上开启个python的http服务(或者使用apache和nginx)，然后将yml文件(访问jar包)和jar包放在根目录下，便于访问 在根目录下放置yml文件，内容如下: 在根目录下放置example.jar包(需要执行的命令)，代码编写及编译方式参考 yaml-payload 步骤二： 设置 spring.cloud.bootstrap.location 属性 spring 1.x spring 2.x 步骤三： 刷新配置 spring 1.x spring 2.x 利用实例这里使用的是python开启http服务。当使用python开启http服务时，根目录为当前执行命令的目录，所以先把yml和jar包放置到根目录下在执行python命令开启http服务 在根目录下放置yml文件，内容如下: 在根目录下放置example.jar包(需要执行的命令)，代码编写及编译方式参考 yaml-payload (代码也在网盘里面，为springcloud-snakeyaml-rce/yaml-payload/src/artsploit/AwesomeScriptEngineFactory.java) 只需将exec()里面修改为执行的命令即可 将其进行打包成jar包 使用python快速开启http服务 通过burp抓包并修改请求报文 然后修改请求报文/refresh，刷新配置文件 反弹shell成功 利用原理 spring.cloud.bootstrap.location 属性被设置为外部恶意 yml 文件 URL 地址 refresh 触发目标机器请求远程 HTTP 服务器上的 yml 文件，获得其内容 SnakeYAML 由于存在反序列化漏洞，所以解析恶意 yml 内容时会完成指定的动作 先是触发 java.net.URL 去拉取远程 HTTP 服务器上的恶意 jar 文件 然后是寻找 jar 文件中实现 javax.script.ScriptEngineFactory 接口的类并实例化 实例化类时执行恶意代码，造成 RCE 漏洞 分析详情参见下文 Exploit Spring Boot Actuator 之 Spring Cloud Env 学习笔记 2.3.Eureka服务漏洞Eureka服务漏洞需要存在两个包 利用条件 可以 POST 请求目标网站的 /env 接口设置属性 可以 POST 请求目标网站的 /refresh 接口刷新配置（存在 spring-boot-starter-actuator 依赖） 目标使用的 eureka-client &lt; 1.8.7（通常包含在 spring-cloud-starter-netflix-eureka-client 依赖中） 目标可以请求攻击者的 HTTP 服务器（请求可出外网） Eureka-Client&lt;1.8.7，eureka服务多用于netflix组件中，可通过在&lt; span=””&gt;/env中搜寻Netflix关键字判断时候可能存在Eureka服务 Eureka服务属性被设置为恶意的外部Eureka serverURL地址时，通过/refresh会触发目标机器请求远程URL,Eureka serverURL可通过在/env处POST数据进行更改 利用方法步骤一: 架设响应Xstream payload的网站 提供一个依赖 Flask 并符合要求的 python 脚本示例，作用是利用目标 Linux 机器上自带的 python 来反弹shell。 使用 python 在自己控制的服务器上运行以上的脚本，并根据实际情况修改脚本中反弹 shell 的 ip 地址和 端口号。 步骤二：监听反弹 shell 的端口 一般使用 nc 监听端口，等待反弹 shell 步骤三：设置 eureka.client.serviceUrl.defaultZone 属性 spring 1.x spring 2.x 步骤四：刷新配置 spring 1.x spring 2.x 利用实例使用python 在服务器上搭建一个响应XStream payload的Web服务，代码如下： Python3启动web,如下: 使用Burp构造请求报文发送POST请求 刷新配置 kali开启监听端口1234获取反弹shell 注：该漏洞的成功利用与jdk版本有关，此处用的是1.8.0_161 利用原理 eureka.client.serviceUrl.defaultZone 属性被设置为恶意的外部 eureka server URL 地址 refresh 触发目标机器请求远程 URL，提前架设的 fake eureka server 就会返回恶意的 payload 目标机器相关依赖解析 payload，触发 XStream 反序列化，造成 RCE 漏洞 详细分析参见下文 Spring Boot Actuator从未授权访问到getshell 2.4.Jolokia漏洞 XXE利用条件 目标网站存在 /jolokia 或 /actuator/jolokia 接口 目标使用了 jolokia-core 依赖（版本要求暂未知）并且环境中存在相关 MBean 目标可以请求攻击者的 HTTP 服务器（请求可出外网） 普通 JNDI 注入受目标 JDK 版本影响，jdk &lt; 6u201/7u191/8u182/11.0.1(LDAP)，但相关环境可绕过 利用方法步骤一:查看已存在的 MBeans 访问 /jolokia/list 接口，查看是否存在 ch.qos.logback.classic.jmx.JMXConfigurator 和 reloadByURL 关键词。 步骤二：托管 xml 文件 在自己控制的 vps 机器上开启一个简单 HTTP 服务器，端口尽量使用常见 HTTP 服务端口（80、443） 在根目录放置以 xml 结尾的 example.xml 文件，内容如下： 步骤三：准备要执行的 Java 代码 编写优化过后的用来反弹 shell 的 Java 示例代码 JNDIObject.java， 使用Maven对其进行编译打包： 然后将生成的 jar包拷贝到 步骤二 中的网站根目录。 步骤四：架设恶意 RMI 服务 设置RMI服务的ip地址和开启服务端口8090 步骤五：监听反弹 shell 的端口 一般使用 nc 监听端口，等待反弹 shell 步骤六：从外部 URL 地址加载日志配置文件 ⚠️ 如果目标成功请求了example.xml 并且 marshalsec 也接收到了目标请求，但是目标没有请求 JNDIObject.class，大概率是因为目标环境的 jdk 版本太高，导致 JNDI 利用失败。 替换实际的 your-vps-ip 地址访问 URL 触发漏洞： 利用实例判断是否存在jolokia插件访问 是否存在 在/jolokia/list 接口搜索关键字： 读取敏感文件 创建xml文档logback.xml 请求访问fileread.dtd文件，192.168.233.1为服务器ip 将该xml放到服务器上，用于访问获取 创建文件fileread.dtd，读取/etc/passwd文件 在外部构造url访问，Payload如下： 可以看到返回的信息中存在etc/passwd的用户信息 如红框中所示 远程代码执行 可以在logback.xml中使用insertFromJNDI标签，这个标签允许我们从 JNDI加载变量，导致了rce漏洞产生。rce的流程主要分为4步。 而 ELProcessor.eval() 会对 EL 表达式（这里为反弹 shell）进行求值，最终达到 RCE的效果。 下面为编写的java代码漏洞利用poc，指定了反弹shell的ip地址和端口及其开启rmi服务的端口 使用maven对java代码进行编译打包 打包成功 将上面打包的jar放到kali上，开启8090端口 使用nc开启监听1234端口 下面为在服务器上放置的logback.xml用来请求kaLi开启的8090端口建立连接 在浏览器中从外部构造url访问 浏览器返回结果如下: 可以看到kali下获取反弹的shell 注: 如果目标成功请求了example.xml并且 marshalsec 也接收到了目标请求，但是目标没有请求JNDIObject.class，大概率是因为目标环境的 jdk 版本太高，导致 JNDI 利用失败。 利用原理 直接访问可触发漏洞的 URL，相当于通过 jolokia 调用ch.qos.logback.classic.jmx.JMXConfigurator 类的 reloadByURL 方法 目标机器请求外部日志配置文件 URL 地址，获得恶意 xml 文件内容 目标机器使用 saxParser.parse 解析 xml 文件 (这里导致了 xxe 漏洞) xml 文件中利用 logback 依赖的 insertFormJNDI 标签，设置了外部 JNDI 服务器地址 目标机器请求恶意 JNDI 服务器，导致 JNDI 注入，造成 RCE 漏洞 详细分析参见下文: spring boot actuator rce via jolokia 2.5.createJNDIRealm RCE利用条件 目标网站存在 /jolokia 或 /actuator/jolokia 接口 目标使用了 jolokia-core 依赖（版本要求暂未知）并且环境中存在相关 MBean 目标可以请求攻击者的服务器（请求可出外网） 普通 JNDI 注入受目标 JDK 版本影响，jdk &lt; 6u141/7u131/8u121(RMI)，但相关环境可绕过 利用方法步骤一：查看已存在的 MBeans 访问 /jolokia/list 接口，查看是否存在 type=MBeanFactory 和 createJNDIRealm 关键词。 步骤二：准备要执行的 Java 代码 编写优化过后的用来反弹 shell 的 Java代码 步骤三： 打包java代码文件 将编辑好的java代码打包成jar包 步骤四：架设恶意 RMI服务 下载 marshalsec ，使用下面命令架设对应的 rmi 服务： 步骤五：监听反弹 shell 的端口 一般使用 nc 监听端口，等待反弹 shell 步骤六：发送恶意 payload 根据实际情况修改 springboot-realm-jndi-rce.py 脚本中的目标地址，RMI 地址、端口等信息，然后在自己控制的服务器上运行 利用实例查看/jolokia/list 中存在的是否存在org.apache.catalina.mbeans.MBeanFactory类提供的createJNDIRealm方法 下面为编写的java代码漏洞利用poc，指定了反弹shell的ip地址和端口及其开启rmi服务的端口 使用maven对java代码进行编译打包 打包成功 使用打包好的jar包-RMIServer-0.1.0.jar指定开启服务的ip地址，运行RMI服务 在kali上使用nc监听1234端口 使用exploit.py脚本对目标进行重放 代码如下: 在kali上使用python运行该脚本，指定目标ip地址和端口 该脚本运行成功后，可以看到kali的nc反弹shell成功 利用原理 创建 JNDIRealm 写入 contextFactory 为 RegistryContextFactory 写入 connectionURL 为你的 RMI Service URL 停止 Realm 启动 Realm 以触发 JNDI 注入 详细分析请参见 Yet Another Way to Exploit Spring Boot Actuators via Jolokia 2.6.restart h2 database query RCE利用条件 可以 POST 请求目标网站的 /env 接口设置属性 可以 POST 请求目标网站的 /restart 接口重启应用 存在 com.h2database.h2 依赖（版本要求暂未知） 利用方法步骤一：设置 spring.datasource.hikari.connection-test-query 属性 ⚠️ 下面payload 中的 ‘T5’ 方法每一次执行命令后都需要更换名称 (如 T6) ，然后才能被重新创建使用，否则下次 restart 重启应用时漏洞不会被触发 spring 1.x（无回显执行命令） str1,str2和str3这三个参数组成要执行的命令 spring 2.x（无回显执行命令） 步骤二：重启应用 spring 1.x spring 2.x 利用实例首先判断在/env变量中是否存在h2.database依赖spring.datasource.hikari.connection-test-query 构造Post请求/actuator/env设置依赖为需要执行的命令，这里使用的是nc反向连接自己的主机192.168.233.242的1234端口 请求数据包如下: 注:T6这个别名参数，每个参数只能使用一次，每个payload用完后要修改这个别名参数，否则不能执行 在自己的主机上使用nc监听1234端口 构造请求/actuator/restart数据包，重启 重启后，可以看到目标连接成功 利用原理 spring.datasource.hikari.connection-test-query 属性被设置为一条恶意的 CREATE ALIAS 创建自定义函数的 SQL 语句 其属性对应 HikariCP 数据库连接池的 connectionTestQuery 配置，定义一个新数据库连接之前被执行的 SQL 语句 restart 重启应用，会建立新的数据库连接 如果 SQL 语句中的自定义函数还没有被执行过，那么自定义函数就会被执行，造成 RCE 漏洞 详细分析参见下文 remote-code-execution-in-three-acts-chaining-exposed-actuators-and-h2-database 2.7restart spring.datasource.data h2 database RCE利用条件 可以 POST 请求目标网站的 /env 接口设置属性 可以 POST 请求目标网站的 /restart 接口重启应用 环境中需要存在 h2database、spring-boot-starter-data-jpa 相关依赖 ⚠️ 目标可以请求攻击者的 HTTP 服务器（请求可出外网），否则 restart 会导致程序异常退出 ⚠️ HTTP 服务器如果返回含有畸形 h2 sql 语法内容的文件，会导致程序异常退出 利用方法步骤一：编写sql 文件并托管 在自己控制的 vps 机器上开启一个简单 HTTP 服务器，端口尽量使用常见 HTTP 服务端口（80、443） 在根目录放置以任意名字的文件，内容为需要执行的 h2 sql 代码，比如： ⚠️ 下面payload 中的 ‘T5’ 方法只能 restart 执行一次；后面 restart 需要更换新的方法名称 (如 T6) 和设置新的 sql URL 地址，然后才能被 restart 重新使用，否则第二次 restart 重启应用时会导致程序异常退出 步骤二：设置 spring.datasource.data 属性 spring 1.x spring 2.x 步骤三：重启应用 spring 1.x spring 2.x 利用实例编写h2 sql语句,执行nc连接目标主机192.168.233.242的端口1234 使用python开启http服务 POST方式构造请求数据包对/actuator/env端点进行请求，设置spring.datasource.data为前面开启http服务的example.sql的url地址 请求报文如下: 在调用/actuator/restart端点进行重启springboot项目 重启springboot后反弹shell成功 ![image-20210830181954887](C:\\Users\\ZR\\Desktop\\springboot\\Spring Boot Actuator未授权访问利用实战利用.assets\\image-20210830181954887.png) 利用原理 目标机器可以通过 spring.datasource.data 属性来设置 jdbc DML sql 文件的 URL 地址 restart 重启应用后，程序会请求设置的 URL 地址 spring-boot-autoconfigure组件中的org.springframework.boot.autoconfigure.jdbc.DataSourceInitializer.java文件代码逻辑中会使用runScripts` 方法执行请求 URL 内容中的 h2 database sql 代码，造成 RCE 漏洞 详细漏洞分析参见如下； repository/springboot-restart-rce 2.8.h2 database console JNDI RCE利用条件 存在 com.h2database.h2 依赖（版本要求暂未知） spring 配置中启用 h2 console spring.h2.console.enabled=true 目标可以请求攻击者的服务器（请求可出外网） JNDI 注入受目标 JDK 版本影响，jdk &lt; 6u201/7u191/8u182/11.0.1（LDAP 方式） 利用方法步骤一：访问路由获得 jsessionid 直接访问目标开启 h2 console 的默认路由 /h2-console，目标会跳转到页面 /h2-console/login.jsp?jsessionid=xxxxxx，记录下实际的 jsessionid=xxxxxx 值。 步骤二：准备要执行的 Java 代码 编写优化过后的用来反弹 shell 的JAVA代码 步骤三：打包JAVA代码 将上面反弹shell的JAVA代码进行打包成jar包 步骤四：架设恶意 RMI服务 指定开启RMI服务的ip地址，使用下面命令架设对应的 RMI服务： 步骤五：监听反弹 shell 的端口 一般使用 nc 监听端口，等待反弹 shell 步骤六：发包触发 JNDI 注入 根据实际情况，替换下面数据中的 jsessionid=xxxxxx、www.example.com 和 RMI://your-vps-ip:port/jndi 利用实例访问目标站点的/h2-console页面，url会跳转到/h2-console/login.jsp?jsessionid=10f21eec1f912ae36cd39c55740101b5 这里的开启RMI服务JAVA代码如下: 反弹shell到192.168.233.242的1234端口 将该代码进行maven打包 然后指定访问ip地址开启RMI服务 使用nc监听端口 构造Post方式请求/h2-console/login.do?session=xxxx，请求报文中指定RMI服务的ip地址和端口 请求报文如下: 可以看到nc连接shell成功 利用原理 设置恶意url参数向h2-console/login.do?session=xxxx发出请求 服务器访问恶意url中的RMI服务，发生JNDI注入 RMI服务执行其他的恶意代码 详细分析参见 Spring Boot + H2数据库JNDI注入 2.9. mysql jdbc deserialization RCE 该环境需要安装Mysql服务和新建数据库，主要还是application.properties配置文件，注意里面的数据库相关配置(请求的数据库名，数据库账户和密码) 利用条件 可以 POST 请求目标网站的 /env 接口设置属性 可以 POST 请求目标网站的 /refresh 接口刷新配置（存在 spring-boot-starter-actuator 依赖） 目标环境中存在 mysql-connector-java 依赖 目标可以请求攻击者的服务器（请求可出外网） 利用方法步骤一：查看环境依赖 GET 请求 /env 或 /actuator/env，搜索环境变量（classpath）中是否有 mysql-connector-java 关键词，并记录下其版本号（5.x 或 8.x）； 搜索并观察环境变量中是否存在常见的反序列化 gadget 依赖，比如 commons-collections、Jdk7u21、Jdk8u20 等； 搜索 spring.datasource.url 关键词，记录下其 value 值，方便后续恢复其正常 jdbc url 值。 步骤二：架设恶意 rogue mysql server 在自己控制的服务器上运行 springboot-jdbc-deserialization-rce.py 脚本，并使用 ysoserial 自定义要执行的命令： 这里使用反序列工具ysoserial(包含所有攻击方式，在环境包中的target目录下)ysoserial可以设置的命令参数如下: 在脚本同目录下生成 payload.ser 反序列化 payload 文件，供脚本使用。 步骤三：设置 spring.datasource.url 属性 ⚠️ 修改此属性会暂时导致网站所有的正常数据库服务不可用，会对业务造成影响，请谨慎操作！ mysql-connector-java 5.x 版本设置属性值为： mysql-connector-java 8.x 版本设置属性值为： spring 1.x spring 2.x 步骤四：刷新配置 spring 1.x spring 2.x 步骤五：触发数据库查询 尝试访问网站已知的数据库查询的接口，例如： /product/list ，或者寻找其他方式，主动触发源网站进行数据库查询，然后漏洞会被触发 步骤六：恢复正常 jdbc url 反序列化漏洞利用完成后，使用 步骤三 的方法恢复 步骤一 中记录的 spring.datasource.url 的原始 value 值 利用实例访问目标站点  查看环境变量设置和依赖 然后架设恶意 rogue mysql server，使用 ysoserial 自定义要执行的命令，讲生成的文件放置在 然后运行 springboot-jdbc-deserialization-rce.py 脚本开启3306端口 POST方式构造请求/actuator/env，设置spring.datasource.url为上面开启服务的ip地址 请求报文如下: 访问/actuator/refresh刷新配置 在接着访问数据库查询的接口，在调用数据库服务的时候就会请求上面设置的url 例如： /product/list ，或者寻找其他方式，主动触发源网站进行数据库查询，然后漏洞会被触发 可以看到前面开启的mysql服务中会显示连接的客户端和返回的一些内容 shell反弹成功 利用原理 spring.datasource.url 属性被设置为外部恶意 mysql jdbc url 地址 refresh 刷新后设置了一个新的 spring.datasource.url 属性值 当网站进行数据库查询等操作时，会尝试使用恶意 mysql jdbc url 建立新的数据库连接 然后恶意 mysql server 就会在建立连接的合适阶段返回反序列化 payload 数据 目标依赖的 mysql-connector-java 就会反序列化设置好的 gadget，造成 RCE 漏洞 详细漏洞分析参见下文 ​ New-Exploit-Technique-In-Java-Deserialization-Attack MySQL-JDBC 反序列化 | CN-SEC 中文网 2.10. restart logging.config logback JNDI RCE利用条件 可以 POST 请求目标网站的 /env 接口设置属性 可以 POST 请求目标网站的 /restart 接口重启应用 普通 JNDI 注入受目标 JDK 版本影响，jdk &lt; 6u201/7u191/8u182/11.0.1(LDAP)，但相关环境可绕过 ⚠️ 目标可以请求攻击者的 HTTP 服务器（请求可出外网），否则 restart 会导致程序异常退出 ⚠️ HTTP 服务器如果返回含有畸形 xml 语法内容的文件，会导致程序异常退出 ⚠️ JNDI 服务返回的 object 需要实现 javax.naming.spi.ObjectFactory 接口，否则会导致程序异常退出 利用方法步骤一：托管 xml 文件 在自己控制的 vps 机器上开启一个简单 HTTP 服务器，端口尽量使用常见 HTTP 服务端口（80、443） 在根目录放置以 xml 结尾的 example.xml 文件，实际内容要根据步骤二中使用的 JNDI 服务来确定： 步骤二：托管RMI服务及代码 编写优化过后的用来反弹 shell 的JAVA代码(只需修改代码中的服务监听端口和反弹shell的ip地址及其端口) 将上面反弹shell的JAVA代码进行打包成jar包 步骤三: 启动RMI服务 指定开启连接RMI服务的主机IP地址，架设RMI服务 步骤三：设置 logging.config 属性 spring 1.x spring 2.x 步骤四：重启应用 spring 1.x spring 2.x 利用实例编写example.xml文档，访问192.168.233.242的RMI服务，放置在开启WEB服务的根目录下 然后使用python开启个简单的http服务 编写恶意RMI服务的反弹shell的JAVA代码,当用户访问该RMI服务时会导致使用nc连接到攻击者的主机，实现反向shell连接 代码如下: 将该代码进行maven打包 ![image-20210830204556955](C:\\Users\\ZR\\Desktop\\springboot\\Spring Boot Actuator未授权访问利用实战利用.assets\\image-20210830204556955.png) 然后指定访问ip地址开启RMI服务 ![image-20210830204855751](C:\\Users\\ZR\\Desktop\\springboot\\Spring Boot Actuator未授权访问利用实战利用.assets\\image-20210830204855751.png) 使用nc监听端口 POST方式构造请求包对/actuator/env发出请求，设置logging.config为前面example.xml的请求地址 然后再访问/actuator/restart端点重新启动项目加载变量 此时就会看到连接shell成功 利用原理 目标机器通过 logging.config 属性设置 logback日志配置文件 URL 地址 restart 重启应用后，程序会请求 URL 地址获得恶意 xml 文件内容 目标机器使用 saxParser.parse 解析 xml 文件 (这里导致了 xxe 漏洞) xml 文件中利用 logback 依赖的 insertFormJNDI 标签，设置了外部 JNDI 服务器地址 目标机器请求恶意 JNDI 服务器，导致 JNDI 注入，造成 RCE 漏洞 2.11. restart logging.config groovy RCE利用条件 可以 POST 请求目标网站的 /env 接口设置属性 可以 POST 请求目标网站的 /restart 接口重启应用 ⚠️ 目标可以请求攻击者的 HTTP 服务器（请求可出外网），否则 restart 会导致程序异常退出 ⚠️ HTTP 服务器如果返回含有畸形 groovy 语法内容的文件，会导致程序异常退出 ⚠️ 环境中需要存在 groovy 依赖，否则会导致程序异常退出 利用方法步骤一：托管 groovy 文件 在自己控制的 vps 机器上开启一个简单 HTTP 服务器，端口尽量使用常见 HTTP 服务端口（80、443） 在根目录放置以 groovy 结尾的 example.groovy 文件，内容为需要执行的 groovy 代码，比如： 步骤二：设置 spring.main.sources 属性 spring 1.x spring 2.x 步骤三：重启应用 spring 1.x spring 2.x 利用实例编写groovy文件并将其放在http服务根目录下 使用python开启http服务 以POST的方式向/actuator/env请求，设置logging.config为groovy的url地址 请求报文如下 ![image-20210831181920688](Spring Boot Actuator未授权访问利用实战利用.assets/image-20210831181920688.png) 在攻击主机上监听1234端口 然后向/actuator/restart请求重启项目 可以看到目标主机反向连接成功 利用原理 目标机器通过 logging.config 属性设置 logback 日志配置文件 URL 地址 restart 重启应用后，程序会请求设置的 URL 地址 logback-classic组件的ch.qos.logback.classic.util.ContextInitializer.java代码文件逻辑中会判断 url 是否以groovy` 结尾 如果 url 以 groovy 结尾，则最终会执行文件内容中的 groovy 代码，造成 RCE 漏洞 2.12. restart spring.main.sources groovy RCE利用条件 可以 POST 请求目标网站的 /env 接口设置属性 可以 POST 请求目标网站的 /restart 接口重启应用 ⚠️ 目标可以请求攻击者的 HTTP 服务器（请求可出外网），否则 restart 会导致程序异常退出 ⚠️ HTTP 服务器如果返回含有畸形 groovy 语法内容的文件，会导致程序异常退出 ⚠️ 环境中需要存在 groovy 依赖，否则会导致程序异常退出 利用方法步骤一：托管 groovy 文件 在自己控制的 vps 机器上开启一个简单 HTTP 服务器，端口尽量使用常见 HTTP 服务端口（80、443） 在根目录放置以 groovy 结尾的 example.groovy 文件，内容为需要执行的 groovy 代码，比如： 步骤二：设置 spring.main.sources 属性 spring 1.x spring 2.x 步骤三：重启应用 spring 1.x spring 2.x 利用实例编写groovy文件并将其放在http服务根目录下 使用python开启http服务 以POST的方式向/actuator/env请求，设置spring.main.sources为groovy的url地址 请求报文如下 在攻击主机上监听1234端口 然后向/actuator/restart请求重启项目 ![image-20210831180134395](C:\\Users\\ZR\\Desktop\\springboot\\Spring Boot Actuator未授权访问利用实战利用.assets\\image-20210831180134395.png) 可以看到目标主机反向连接成功 ![image-20210831180922722](C:\\Users\\ZR\\Desktop\\springboot\\Spring Boot Actuator未授权访问利用实战利用.assets\\image-20210831180922722.png) 利用原理 目标机器可以通过 spring.main.sources 属性来设置创建 ApplicationContext 的额外源的 URL 地址 restart 重启应用后，程序会请求设置的 URL 地址 spring-boot组件中的org.springframework.boot.BeanDefinitionLoader.java文件代码逻辑中会判断 url 是否以.groovy` 结尾 如果 url 以 .groovy 结尾，则最终会执行文件内容中的 groovy 代码，造成 RCE 漏洞 3.安全措施3.1开启security依赖功能在项目的pom.xml文件下引入spring-boot-starter-security依赖 然后在application.properties中开启security功能，配置访问账号密码，重启应用即可弹出。 3.2禁用接口如果上述请求接口不做任何安全限制，安全隐患显而易见。实际上SpringBoot也提供了安全限制功能。比如要禁用/env接口，则可设置如下： endpoints.env.enabled= false 如果只想打开一两个接口，那就先禁用全部接口，然后启用需要的接口： "},{"title":"Struts2漏洞复现总结","date":"2021-09-13T01:39:53.000Z","url":"/2021/09/13/Struts2%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0%E6%80%BB%E7%BB%93/","tags":[["Struts2漏洞复现总结","/tags/Struts2%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0%E6%80%BB%E7%BB%93/"]],"categories":[["渗透","/categories/%E6%B8%97%E9%80%8F/"]],"content":"Struts2漏洞复现总结简介Struts2是一个基于MVC设计模式的Web应用框架，它本质上相当于一个servlet，在MVC设计模式中，Struts2作为控制器(Controller)来建立模型与视图的数据交互。Struts 2是Struts的下一代产品，是在 struts 1和WebWork的技术基础上进行了合并的全新的Struts 2框架。其全新的Struts 2的体系结构与Struts 1的体系结构差别巨大。Struts 2以WebWork为核心，采用拦截器的机制来处理用户的请求，这样的设计也使得业务逻辑控制器能够与ServletAPI完全脱离开，所以Struts 2可以理解为WebWork的更新产品。虽然从Struts 1到Struts 2有着非常大的变化，但是相对于WebWork，Struts 2的变化很小。 S2-001该漏洞因为用户提交表单数据并且验证失败时，后端会将用户之前提交的参数值使用 OGNL 表达式 %{value} 进行解析，然后重新填充到对应的表单数据中。例如注册或登录页面，提交失败后端一般会默认返回之前提交的数据，由于后端使用 %{value} 对提交的数据执行了一次 OGNL 表达式解析，所以可以直接构造 Payload 进行命令执行 进入s2-001的docker漏洞环境 首先使用%&#123;&#39;test&#39;&#125;进行测试漏洞是否存在 返回了test，证明存在漏洞 使用payload进行测试，返回了tomcatBinDir&#123;/usr/local/tomcat&#125; 使用payload执行whoami 使用payload执行cat /etc/password命令 S2-005s2-005漏洞的起源源于S2-003(受影响版本: 低于Struts 2.0.12)，struts2会将http的每个参数名解析为OGNL语句执行(可理解为java代码)。OGNL表达式通过#来访问struts的对象，struts框架通过过滤#字符防止安全问题，然而通过unicode编码(\\u0023)或8进制(\\43)即绕过了安全限制，对于S2-003漏洞，官方通过增加安全配置(禁止静态方法调用和类方法执行等)来修补，但是安全配置被绕过再次导致了漏洞，攻击者可以利用OGNL表达式将这2个选项打开，S2-003的修补方案把自己上了一个锁，但是把锁钥匙给插在了锁头上。XWork会将GET参数的键和值利用OGNL表达式解析成Java语句，如： 触发漏洞就是利用了这个点，再配合OGNL的沙盒绕过方法，组成了S2-003。官方对003的修复方法是增加了安全模式（沙盒），S2-005在OGNL表达式中将安全模式关闭，又绕过了修复方法。整体过程如下： S2-003 使用\\u0023绕过s2对#的防御 S2-003 后官方增加了安全模式（沙盒） S2-005 使用OGNL表达式将沙盒关闭，继续执行代码 影响版本: 2.0.0 - 2.1.8.1 进入s2-005的docker环境 抓包添加payload执行往/tmp/目录下写入success文件的操作 进入docker容器查看，在tmp目录下已经创建了success文件 S2-007在s2-007页面的文本框中，age来自于用户输入，传递一个非整数给id导致错误，struts会将用户的输入当作ongl表达式执行，从而导致了漏洞 进入s2-007的docker漏洞环境 执行payload列出当前目录下的所有文件 添加payload执行whoami 也可以直接在age文本框处使用payload 即可得到id S2-008s2-008漏洞产生的原因，主要是利用对传入参数没有严格限制，导致多个地方可以执行恶意代码，传入?debug=command&amp;expression=即可执行OGNL表达式 进入s2-008的docker环境 在GET包处添加payload执行whoami S2-009Struts2对S2-003的修复方法是禁止#号，于是s2-005通过使用编码\\u0023或\\43来绕过；后来Struts2对S2-005的修复方法是禁止\\等特殊符号，使用户不能提交反斜线。 但是，如果当前action中接受了某个参数example，这个参数将进入OGNL的上下文。所以，我们可以将OGNL表达式放在example参数中，然后使用/helloword.acton?example=&lt;OGNL statement&gt;&amp;(example)(&#39;xxx&#39;)=1的方法来执行它，从而绕过官方对#、\\等特殊字符的防御。 影响版本Struts 2.1.0-2.3.1.1 进入S2-009的docker环境 访问192.168.1.8:8080/ajax/example5，此为存在漏洞的界面 将payload拼接读取passwd文件 S2-012如果在配置 Action 中 Result 时使用了重定向类型，并且还使用 ${param_name} 作为重定向变量，例如： 这里 UserAction 中定义有一个 name 变量，当触发 redirect 类型返回时，Struts2 获取使用 ${name} 获取其值，在这个过程中会对 name 参数的值执行 OGNL 表达式解析，从而可以插入任意 OGNL 表达式导致命令执行 进入s2-012的docker环境 直接在文本框内执行payload读取passwd 点击提交即可读取到passwd S2-013Struts2 标签中 &lt;s:a&gt; 和 &lt;s:url&gt; 都包含一个 includeParams 属性，其值可设置为 none，get 或 all，参考官方其对应意义如下：none - 链接不包含请求的任意参数值（默认） get - 链接只包含 GET 请求中的参数和其值 all - 链接包含 GET 和 POST 所有参数和其值 &lt;s:a&gt;用来显示一个超链接，当includeParams=all的时候，会将本次请求的GET和POST参数都放在URL的GET参数上。在放置参数的过程中会将参数进行OGNL渲染，造成任意命令执行漏洞。 进入s2-013的docker环境 这里直接构造链接并进行url编码： 认准exec执行系统命令即可，flag在环境变量里面，构造： S2-015s2-015漏洞远程攻击者可借助带有‘${}’和‘%{}’序列值（可导致判断OGNL代码两次）的请求，利用该漏洞执行任意OGNL代码 进入s2-015的docker环境 首先构造{1+1}得到payload 执行后自动编码得到如下，在message处会回显 构造payload显示id 这里在message处得到id需要进行url解码 S2-016在struts2中，DefaultActionMapper类支持以”action:”、“redirect:”、”redirectAction:”作为导航或是重定向前缀，但是这些前缀后面同时可以跟OGNL表达式，由于struts2没有对这些前缀做过滤，导致利用OGNL表达式调用java静态方法执行任意系统命令 进入s2-016的docker环境 构造payload执行，可以发现执行过后网址后面出现了id S2-032当启用动态方法调用时，可以传递可用于在服务器端执行任意代码的恶意表达式。method: Action 前缀去调用声明为 public 的函数，只不过在低版本中 Strtus2 不会对 name 方法值做 OGNL 计算，而在高版本中会。. 进入s2-032的docker环境 构造payload返回1001060253718则代表可代码执行 构造payload输出id S2-045Apache Struts 2被曝存在远程命令执行漏洞，漏洞编号S2-045，CVE编号CVE-2017-5638，在使用基于Jakarta插件的文件上传功能时，有可能存在远程命令执行，导致系统被黑客入侵。恶意用户可在上传文件时通过修改HTTP请求头中的Content-Type值来触发该漏洞，进而执行系统命令。 影响范围 Struts 2.3.5 – Struts 2.3.31 Struts 2.5 – Struts 2.5.10 进入s2-045的docker环境 构造payload任意命令执行 对于payload的一些解释 来获取上下文容器 通过容器实例化，对Ognl API的通用访问，设置和获取属性 判断目标主机的操作系统类型，并进行执行命令赋值 执行攻击命令 S2-046s2-046漏洞的利用有点特殊，需要满足以下几个条件： 1、系统必须使用 Jakarta 插件，检查 Struts2 配置文件中是否有以下配置：&lt;constant name =“struts.multipart.parser”value =“jakarta-stream”/&gt; 2、上传文件的大小（由 Content-LSength 头指定）大于 Struts2 允许的最大大小（2GB） 3、文件名内容构造恶意的 OGNL 内容。 如果满足以上要求，Struts2 受影响版本将创建一个包含攻击者控制的异常文件名，使用 OGNL 值堆栈来定位错误消息，OGNL 值堆栈将插入任何 OGNL 变量（$ {}或％{}）作为 OGNL 表达式，然后实现任意代码执行。 与045相同，046也是OGNL注入，但出现在上传请求的文件名字段中，并且需要NUL字节来拆分有效负载和其余字符串。 进入s2-046的docker环境 点击submit进行抓包，可以看到这里的filename正常情况下是为空的 构造payload执行1+99 这里需要进行00截断，进入hex将30改为00 然后发包，可以看到X-Test这个地方已经执行了1+99并输出了结果 那么这里就可以构造一个poc进行bash反弹，还是要进行00阶段，nc监听端口，发包即可得到反弹shell S2-048这个漏洞主要问题出在struts2-struts1-plugin这个插件包上。这个库的主要作用就是将struts1的action封装成struts2的action以便它能在strut2上运行使用。 而由于struts2-struts1-plugin 包中的 “Struts1Action.java” 中的 execute 函数可以调用 getText() 函数，这个函数刚好又能执行OGNL表达式，同事这个 getText() 的 参数输入点，又可以被用户直接进行控制，用户可控的值添加到 ActionMessage 并在客户前端展示，导致其进入 getText 函数，最后 message 被当作 ognl 表达式执行如果这个点被恶意攻击者所控制，就可以构造恶意执行代码，从而实现一个RCE攻击。 进入s2-048的docker环境 进入漏洞页面，尝试运算1+1 可以看到这里得到了运算结果，说明存在漏洞 那么这里构造一个payload用来输出id 构造payload输出whoami S2-052s2-052产生漏洞的原因是REST插件使用到XStreamHandler处理xml数据，由于未对xml数据做任何过滤，在进行发序列xml数据转换为Object时导致RCE 进入s2-052的docker环境 进入页面后随便点击一个成员进行编辑并点击submit进行抓包 这里可以看到Content-Type为application/x-www-form-urlencoded 构造一个xml文件 首先将Content-Type改为application/xml，然后将xml文件插入，发包返回500证明已经成功 进入tmp目录查看success文件已经创建成功 S2-053s2-053漏洞产生的原因是Struts2在使用Freemarker模板引擎的时候，同时允许解析OGNL表达式。导致用户输入的数据本身不会被OGNL解析，但由于被Freemarker解析一次后变成离开一个表达式，被OGNL解析第二次，导致任意命令执行漏洞。 进入s2-053的docker环境 首先执行%&#123;33-1&#125;并提交，可以看到在Your url的地方运算出了结果，说明存在漏洞 构造payload输出id并提交 执行bash反弹命令，用nc监听端口即可得到反弹shell S2-057s2-057漏洞产生于网站配置XML时如果没有设置namespace的值，并且上层动作配置中并没有设置或使用通配符namespace时，可能会导致远程代码执行漏洞的发生。同样也可能因为url标签没有设置value和action的值，并且上层动作并没有设置或使用通配符namespace，从而导致远程代码执行漏洞的发生。 alwaysSelectFullNamespace被设置为true，此时namespace的值是从URL中获取的。URL是可控的，所以namespace也是可控的action元素没有名称空间属性集，或者使用通配符。该名称空间将由用户从URL传递并解析为OGNL表达式，最终导致远程代码执行的脆弱性。 进入s2-057的docker环境 首先构造12+34回车 发现运算出了结果，说明存在漏洞 构造payload输出id 进行url编码 得到如下payload bp抓包在GET处进行拼接得到id 在exec处修改要执行得命令即可 S2-059s2-059产生的原因为攻击者可以通过构造恶意的OGNL表达式，并将其设置到可被外部输入进行修改，且会执行OGNL表达式的Struts2标签的属性值，引发OGNL表达式解析，最终造成远程代码执行的影响。 进入s2-059的docker环境 访问8080看到有一个input:id 传参id=2进入发现出现在了input id:这个地方 这里构造id=%25&#123;10*10&#125;，发现自动进行了运算 使用bash反弹，先进行编码 编码后结果如下 生成一个test.py，将bash编码放入py 执行即可得到反弹shell S2-061s2-061漏洞产生的原因是Struts2 会对某些标签属性(比如 id，其他属性有待寻找) 的属性值进行二次表达式解析，因此当这些标签属性中使用了 %&#123;x&#125; 且 x 的值用户可控时，用户再传入一个 %&#123;payload&#125; 即可造成OGNL表达式执行。S2-061是对S2-059沙盒进行的绕过 进入s2-061的docker环境 还是构造一个%25&#123;10*10&#125;发现运算成功，证明漏洞存在 bp在index.action页面抓包 修改Content-Type如下并添加数据，这里如果直接使用GET方法是得不到回显的 改为POST方法即可得到id 配合dnslog食用同理 bash反弹命令需要先进行编码，同之前操作 nc监听端口即可得到反弹shell "},{"title":"Github渗透测试工具库-2021版","date":"2021-08-16T16:23:27.000Z","url":"/2021/08/17/Github%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95%E5%B7%A5%E5%85%B7%E5%BA%93-2021%E7%89%88/","categories":[["渗透","/categories/%E6%B8%97%E9%80%8F/"]],"content":"1.前言今天看到一个博客里有这个置顶的工具清单，但是发现这些都是很早以前就有文章发出来的，我爬下来后一直放在txt里吃土。这里一起放出来。 2.漏洞练习平台WebGoat漏洞练习平台： webgoat-legacy漏洞练习平台: zvuldirll漏洞练习平台： vulapps漏洞练习平台： dvwa漏洞练习平台： 数据库注入练习平台 ： 用node编写的漏洞练习平台，like OWASP NodeGoat： Ruby编写的一款工具，生成含漏洞的虚拟机： 3.花式扫描器Nmap端口扫描器： 本地网络扫描器： 子域名扫描器： Linux漏洞扫描： 基于端口扫描以及关联CVE: 漏洞路由扫描器： 迷你批量信息泄漏扫描脚本： Waf类型检测工具： 服务器端口弱口令扫描器： Fox-scan扫描器： 4.信息搜集工具社工收集器： Github信息搜集： github Repo信息搜集工具： 信息探测及扫描工具： 内部网络信息扫描器： 远程桌面登录扫描器： 网络基础设施渗透工具： SNMAP密码破解: 5.WEBwebshell大合集： 渗透以及web攻击脚本： web渗透小工具大合集： XSS数据接收平台： XSS与CSRF工具： xss多功能扫描器： web漏洞扫描器: WEB漏洞扫描器： 渗透常用小工具包： web目录扫描器: web向命令注入检测工具： 自动化SQL注入检查工具： SSL扫描器： 安全工具集合： apache日志分析器： php代码审计工具： web指纹识别扫描： 检查网站恶意攻击： wordprees漏洞扫描器： 固件漏洞扫描器： 数据库注入工具： Web代理： 新版中国菜刀： git泄露利用EXP： 浏览器攻击框架： 自动化绕过WAF脚本： 一款开源WAF： http命令行客户端： 浏览器调试利器： DISCUZ漏洞扫描器： 自动化代码审计工具： 浏览器攻击框架： tomcat自动后门部署： 网络空间指纹扫描器： burpsuit之J2EE扫描插件： 6.Windows域渗透工具mimikatz明文注入： Powershell渗透库合集： Powershell tools合集： powershell的mimikittenz: 域渗透教程: 7.FuzzWeb向Fuzz工具： HTTP暴力破解，撞库攻击脚本： 8.漏洞利用及攻击框架msf框架： pocsscan攻击框架： Pocsuite攻击框架: Beebeeto攻击框架： 漏洞POC&amp;EXP:ExploitDB官方git版本: php漏洞代码分析 CVE-2016-2107: CVE-2015-7547 POC： JAVA反序列化POC生成工具: JAVA反序列化EXP: Jenkins CommonCollections EXP: CVE-2015-2426 EXP (windows内核提权): use docker to show web attack(php本地文件包含结合phpinfo getshell 以及ssrf结合curl的利用演示): php7缓存覆写漏洞Demo及相关工具: XcodeGhost木马样本: 9.中间人攻击及钓鱼中间人攻击框架: Inject code, jam wifi, and spy on wifi users: 中间人代理工具: wifi钓鱼: 10.密码破解密码破解工具: 本地存储的各类密码提取利器: 11.二进制及代码分析工具二进制分析工具： 系统扫描器： rp: Windows Exploit Development工具： 二进制静态分析工具（python）: Python Exploit Development Assistance for GDB: 对BillGates Linux Botnet系木马活动的监控工具 木马配置参数提取工具: Shellphish编写的二进制分析工具（CTF向）: 针对python的静态代码分析工具: 一个自动化的脚本（shell）分析工具，用来给出警告和建议: 基于AST变换的简易Javascript反混淆辅助工具: 12.EXP编写框架及工具二进制EXP编写工具: CTF Pwn 类题目脚本编写框架: an easy-to-use io library for pwning development: 跨平台注入工具: 哈希长度扩展攻击EXP： 13.隐写隐写检测工具： 14.各类安全资料data_hacking合集: mobile-security-wiki: 书籍《reverse-engineering-for-beginners》: 一些信息安全标准及设备配置: APT相关笔记: Kcon资料: 《DO NOT FUCK WITH A HACKER》: 各类安全脑洞图： 信息安全流程图： 15.各类CTF资源近年ctf writeup大全： fbctf竞赛平台Demo: ctf Resources: ctf及黑客资源合集: ctf和安全工具大合集: ctf向 python工具包： 16.各类编程资源大礼包（什么都有）： bash-handbook: python资源大全: git学习资料: 安卓开源代码解析 python框架，库，资源大合集: JS 正则表达式库（用于简化构造复杂的JS正则表达式）: 17.Pythonpython 正则表达式库（用于简化构造复杂的python正则表达式）: python任务管理以及命令执行库: python exe打包库: Veil-Evasion免杀项目： py3 爬虫框架: 一个提供底层接口数据包编程和网络协议支持的python库: python requests 库 python 实用工具合集: python爬虫系统 18.福利微信自动抢红包动态库： 微信抢红包插件（安卓版 hardsed神器: 19.甲方安全工程师生存指南 web索引及日志搜索工具： 开源日志采集器： 扫描CS结构的web debuger 恢复sqlite数据库删除注册信息： gps欺骗检测工具: 应急处置响应框架: web安全开发指南: 各个知名厂商漏洞测试报告模板： linux下恶意代码检测包： 操作系统运行指标可视化框架： 恶意代码分析系统： 定期搜索及存储web应用： 事件响应框架： 综合主机监控检测平台： 分布式实时数字取证系统： Microsoft &amp; Unix 文件系统及硬盘取证工具： 20.蜜罐SSH蜜罐： 蜜罐集合资源： kippo进阶版蜜罐： SMTP 蜜罐： web应用程序蜜罐： 数据库蜜罐： web蜜罐： 21.远控用gmail充当C&amp;C服务器的后门： 开源的远控： c#远控： 22.工具合集(NoSQL扫描/爆破工具) (MySQL盲注爆破工具) (基于SQLMAP的主动和被动资源发现的漏洞扫描工具) (用于SQL Server审计的powershell脚本) (用于http header中的时间盲注爆破工具，仅针对MySQL / MariaDB) (Java编写的SQL注入工具) (基于搜索引擎的批量SQL注入漏洞扫描器) (在sqlmap基础上增加了目录扫描，hash爆破等功能) (Mysys以及MSSQL爆破脱裤工具) (批量查询网站在乌云是否存在忽略的sql注入漏洞并自动调用sqlmap测试) (一个简单的HTTP暴力破解，撞库攻击脚本) (对各类服务进行弱口令检测的脚本) (根据用户习惯生成弱口令探测字典脚本) (Go写的协程版的ssh \\redis \\ mongodb弱口令破解工具) (暴力破解字典建立工具) (多线程探测弱口令) (支持测试CSRF，Clickjacking，Cloudflare和WAF的弱口令探测器) (对CiscoVPN，Citrix Gateway等各类服务进行弱口令检测的脚本) (物联网设备默认密码扫描检测工具) (使用nmap扫描IoT设备) (路由器设备漏洞扫描利用) (Telnet服务密码撞库) (自动化信息搜集及渗透测试工具，比较适用于IoT扫描) (嵌入式设备漏洞扫描及利用工具) (一款XSS扫描器，可暴力注入参数) (小型XSS扫描器，也可检测CRLF，XSS，点击劫持的) (PHP版本的反射型xss扫描) (批量扫描XSS的python脚本) (自动化检测页面是否存在XSS和跨站请求伪造漏洞的浏览器插件) (使用命令行进行XSS批量检测) (可识别和绕过WAF的XSS扫描工具) (支持GET，POST方式的高效XSS扫描器) (网络资产识别引擎，漏洞检测引擎) (企业被搜索引擎收录敏感资产信息监控脚本：员工邮箱，子域名，主持人) (Bing，google，360，zoomeye 等搜索引擎聚合搜索，可用于发现企业被搜索引擎收录的敏感资产信息) (能成抓取搜索引擎隐藏的url，并交由sqlmap，nmap扫描) (企业内网基础服务安全扫描框架) (github Repo信息搜集工具) (.svn文件夹泄漏利用工具) (GitHub敏感信息扫描工具) (企业资产，敏感信息GitHub泄露监控系统) (根据企业关键词进行项目检索以及相应敏感文件和文件内容扫描的工具) (github敏感信息搜索工具) ( .git文件夹泄漏利用工具) (GitHub敏感信息扫描工具，包括检测提交等) (自动化对指定域名进行Google hacking搜索并收集信息) (用于搜索git的承诺中的敏感信息，例如密码，私钥等的客户端工具) (Github敏感信息泄露扫描) (Github泄露巡航工具) (Web站点信息搜集工具，包括邮箱，电话等信息) (集合多个开源GitHub敏感信息扫描的企业信息泄露巡航工具) (可以提取网址，电子邮件，文件，网站帐户等的高速爬虫) (一款简单的webshell检测工具) (哈勃分析系统，LINUX系统病毒分析及安全检测) (使用python实现的集成ClamAV，ESET，Bitdefender的反病毒引擎) (一款高效率PHP-webshell扫描工具) (测试效率高达99%的webshell检测工具) (一款简洁的的Webshell扫描工具) (Webshell扫描工具，支持php / perl / asp / aspx webshell扫描) (一款木马，僵尸网络分析框架) (高级安卓木马病毒分析框架) (基于网络流量的内网探测框架) (调用Windows API枚举用户登录信息) (自动化利用XSS入侵内网) (目标端口扫描+系统服务指纹识别) (动态多线程敏感信息泄露检测工具) (WAF产品指纹识别) (SSL类型识别) (Web指纹识别) (Web应用指纹识别) (网络爬虫式指纹识别) (基于Masscan和Zmap的网络扫描器) (网络资产信息扫描，ICMP存活探测，端口扫描，端口指纹服务识别) (中间件扫描) (web路径收集与扫描) (C段横幅与路径扫描) (端口服务扫描) (waf自动暴破) (尝试找出cdn背后的真实ip) (基于Bing搜索引擎的C段/旁站查询，多线程，支持API) (多线程WEB目录爆破工具) (一个爬虫式的网段Web主机发现小工具) (Thorn上实现的分布式任务分发的ip端口漏洞扫描器) (类似zgrab的快速TCP指纹抓取解析工具，支持更多协议) (CDN识别，检测) (基于爬虫的web路径扫描器) (服务器ssh配置信息扫描) (针对域名及其子域名的资产数据检测/扫描，包括http / https检测等) (域名资产收集及指纹识别工具) (CMS识别python gevent实现) (敏感文件扫描/二次判断降低误报率/扫描内容规则化/多目录扫描) (基于爬虫的动态敏感文件探测工具) (web路径扫描工具) (网络设备web服务指纹扫描与检索) (目标主机服务ssl类型识别) (Web应用fuzz工具，框架，同时可用于web路径/服务扫描) (多线程的后台路径扫描器，也可用于发现重定向漏洞后执行) (弱口令扫描器，不仅支持普通登录页，也支持ssh，mongodb等组件) (渗透测试辅助工具，支持分析数据包，解码，端口扫描，IP地址分析等) (基于nmap的扫描器，与cve漏洞关联) (基于nmap的高级漏洞扫描器，命令行环境使用) (web应用信息搜集工具) (围绕web服务的域名进行信息收集和“域传送”等漏洞扫描，也支持针对背后的服务器端口扫描等) (基于Nikto扫描规则的被动式路径扫描以及信息爬虫) (快速识别WEB服务器类型，CMS类型，WAF类型，WHOIS信息，以及语言框架) (用于检查web服务的http header的安全性) (一款高效快捷的敏感文件扫描工具) (通过字典穷举，google，robots.txt等途径的跨平台后台管理路径扫描器) (常规CMS指纹识别) (WAF指纹识别及自动化绕过工具) (网络应用模糊工具，框架，同时可用于网络路径/服务扫描) (web敏感目录/信息泄漏扫描脚本) (用于网站或IP地址的信息收集工具) (通过扫描全网获得真实IP的自动化程序) (分布式WEB指纹识别平台) (爬虫式web目录扫描工具) (Jenkins漏洞探测，用户抓取爆破) (首款集成化的Discuz扫描工具) (一款简洁优雅的CMS扫描利用框架) (IIS短文件名暴力枚举漏洞利用工具) (flashxss扫描) (一个起毛服务器端模板注入漏洞的半自动化工具) (服务器端模板注入漏洞检测与利用工具) (Docker扫描工具) (一款精简的wordpress扫描工具) (集成化wordpress漏洞利用框架) (用于扫描J2EE应用的一款burpsuite插件) (一款基于perl的strut2的历史漏洞扫描器) (本地文件包含漏洞利用及扫描工具，支持反弹shell) (基于Salt Open以及Vulners Linux Audit API的linux漏洞扫描器，支持与JIRA，slack平台结合使用) (自动化探测客户端AngularJS模板注入漏洞工具) (Java编写的IIS短文件名暴力枚举漏洞利用工具) (基于WPScan以及WPSeku的优化版wordpress扫描器) (CMS渗透测试框架) (CRLF注入漏洞批量扫描) (自动化扫描内网中存在的由影子经纪人泄露的ETERNAL系列漏洞) (通过定制化的谷歌搜索引擎进行漏洞页面搜寻及扫描) (本地文件包含漏洞利用及扫描工具，支持反弹shell) (用于枚举脚本的GET / POST未知参数字段) (struts2的漏洞全版本检测和利用工具) (SSL漏洞扫描，例如心脏滴血漏洞等) (基于搜索引擎的漏洞网页搜寻) (用于攻击爆破Java RemoteMethod Invocation服务的工具) (扫描js扩展库的常见漏洞) (针对的hadoop /火花等大数据平台的的漏洞探测工具) (RegEx拒绝服务扫描器) (使用NMAP扫描的Tor网络上隐藏的“洋葱”服务) (Web CMS Exploit工具，包含针对主流CMS的66个不同的漏洞利用) (一个迷你的信息泄漏批量扫描脚本) (文件上传漏洞扫描器及利用工具) (子域名接管漏洞检测工具，支持30+云服务托管检测) (WordPress的漏洞扫描器，同时也支持敏感文件泄露扫描) (检测网站依赖的JavaScript库中存在的已知通用漏洞) (自动检测上传功能是否可上传webshell) (CMS指纹识别及自动化渗透测试框架) (论坛框架vBulletin黑盒漏洞扫描器) (CMS指纹识别及自动化渗透测试框架) (CMS漏洞检测和利用套件) (AWS安全审计工具) (针对wp，magento，joomla等CMS的漏洞扫描器及自动利用工具) (OWASP旗下joomla漏洞扫描项目) (用于检测因错误配置导致敏感信息暴露的Django应用程序) (无线安全审计工具) (Python网络/渗透测试工具) (无线安全渗透测试套件) (无线网络审计工具，支持2-5GHZ频段) (ARP欺骗，无线网络劫持) (检查wifi是否是“大菠萝”所开放的热点，并给予网络评分) (自动化无线网络攻击工具wifite的重构版本) (基于BBScan via.lijiejie的本地网络扫描) (基于JavaScript的的本地网络扫描 (白盒代码安全审计系统) (静态PHP代码审计) (跟踪，分析PHP运行情况的工具) (NodeJS应用代码审计) (Python应用审计) (Ruby on Rails应用静态代码分析) (Python应用静态代码审计) (WordPress插件代码安全审计) (用于扫描PHP应用程序中可能存在SQL漏洞的ADOdb代码)  (用于检测潜在安全漏洞的PHP静态代码分析工具)  (自动漏洞扫描器，子域名爆破，端口扫描，目录爆破，常用框架漏洞检测)  (集合owasp top10漏洞扫描和边界资产发现能力的分布式web漏洞扫描框架)  (BkScanner分布式，插件化web漏洞扫描器)  (ysrc出品的被动式漏洞扫描工具)  (基于http代理的web漏洞扫描器)  (自动化扫描器，包括中间件扫描以及设备指纹识别)  (定向全自动化渗透测试工具)  (自动化渗透测试框架，支持cdn真实ip查找，指纹识别等)  (蟒插件化漏洞扫描器，支持生成扫描报表)  (渗透测试插件化并发框架)  (支持检测SQLI/ XSS / LFI / RFI等漏洞的扫描器)  (Web图形化的漏洞扫描框架)  (一款网络化的自动化渗透测试框架)  (一款集成信息收集，漏洞扫描，指纹识别等的多合一扫描工具)  (高度集成化的Web应用漏洞扫描框架，支持REST，RPC等api调用)  (集成化渗透测试辅助平台及漏洞管理平台)  (渗透测试集成框架，包含超过38,000+攻击)  (基于铬/歌剧插件的被动式漏洞扫描)  (支持多种网络漏洞扫描，命令行环境使用)  (web应用扫描器，支持指纹识别，文件目录爆破，SQL / XSS / RFI等漏洞扫描，也可直接用于struts，ShellShock等扫描)  (集成子域名枚举，nmap，waf指纹识别等模块的web应用扫描器)  (使用ruby开发的扫描网络中主机存在的第三方web应用服务漏洞)  (Web应用自动化扫描框架，支持自动化上传webshell)  (一款开源Poc调用框架，可轻松调用Pocsuite，Tangscan，Beebeeto，Knowsec老版本POC，可使用docker部署)  (斗象能力中心出品并长期维护的开源漏洞检测框架)  (Web应用漏洞扫描框架)  (Web应用漏洞扫描框架，基于python3)  (被动式漏洞扫描，支持历史cve编号漏洞识别)  (OWASP ZAP核心项目出品的综合性渗透测试工具)  (Web服务综合型扫描器，用于指定目标的资产收集，安全配置缺陷或者安全漏洞扫描)  (一款多方位信息收集，指纹识别及漏洞扫描工具)  (一款web应用漏洞扫描器，支持扫描反射型以及存储型xss，sql injection等漏洞，支持输出pdf报告)  (渗透测试辅助工具，综合利用框架) (基于被动式扫描框架的自动化web漏洞扫描工具) (渗透测试辅助框架，包含信息搜集，无线渗透，网络应用扫描等功能) (内置1200+插件的web漏洞扫描框架) (Web服务安全评估工具，提供基于windows操作系统的简单.exe应用) (使用去开发的可扩展以及高并发渗透测试框架) (基于Flask应用框架的漏洞扫描系统) (一个操作上类似metasploit的web应用安全审计框架 (一款web应用漏洞扫描器，支持扫描反射型以及存储型xss，sql injection等漏洞) (集成104个模块的Web应用程序渗透测试框架) (一款APT入侵痕迹扫描器) (ICS设备nmap扫描脚本) (SDN安全评估框架) "},{"title":"Web中间件常见漏洞总结（一）","date":"2021-08-15T12:37:52.000Z","url":"/2021/08/15/Web%E4%B8%AD%E9%97%B4%E4%BB%B6%E5%B8%B8%E8%A7%81%E6%BC%8F%E6%B4%9E%E6%80%BB%E7%BB%93/","tags":[["iis","/tags/iis/"]],"categories":[["渗透","/categories/%E6%B8%97%E9%80%8F/"]],"content":"*本文中涉及到的相关漏洞已报送厂商并得到修复，本文仅限技术研究与讨论，严禁用于非法用途，否则产生的一切后果自行承担。 一、 常见web中间件及其漏洞概述（一） IIS1、PUT漏洞 2、短文件名猜解 3、远程代码执行 4、解析漏洞 （二） Apache1、解析漏洞 2、目录遍历 （三） Nginx1、文件解析 2、目录遍历 3、CRLF注入 4、目录穿越 （四）Tomcat1、远程代码执行 2、war后门文件部署 （五）jBoss1、反序列化漏洞 2、war后门文件部署 （六）WebLogic1、反序列化漏洞 2、SSRF 3、任意文件上传 4、war后门文件部署 （七）其它中间件相关漏洞1、FastCGI未授权访问、任意命令执行 2、PHPCGI远程代码执行 二、 IIS漏洞分析（一） IIS简介IIS是Internet Information Services的缩写，意为互联网信息服务，是由微软公司提供的基于运行Microsoft Windows的互联网基本服务。最初是Windows NT版本的可选包，随后内置在Windows 2000、Windows XP Professional和Windows Server 2003一起发行，但在Windows XP Home版本上并没有IIS。IIS是一种Web（网页）服务组件，其中包括Web服务器、FTP服务器、NNTP服务器和SMTP服务器，分别用于网页浏览、文件传输、新闻服务和邮件发送等方面，它使得在网络（包括互联网和局域网）上发布信息成了一件很容易的事。 IIS的安全脆弱性曾长时间被业内诟病，一旦IIS出现远程执行漏洞威胁将会非常严重。远程执行代码漏洞存在于 HTTP 协议堆栈 (HTTP.sys) 中，当 HTTP.sys 未正确分析经特殊设计的 HTTP 请求时会导致此漏洞。成功利用此漏洞的攻击者可以在系统帐户的上下文中执行任意代码，可以导致IIS服务器所在机器蓝屏或读取其内存中的机密数据 （二） PUT漏洞1、漏洞介绍及成因 IIS Server 在 Web 服务扩展中开启了 WebDAV ，配置了可以写入的权限，造成任意文件上传。 版本： IIS6.0 2、漏洞复现 1） 开启WebDAV 和写权限 2） 利用burp测试 抓包，将GET请求改为OPTIONS 3）利用工具进行测试 成功上传，再上传一句话木马，然后用菜刀连接，getshell 3、漏洞修复 关闭WebDAV 和写权限 （二）短文件名猜解1、漏洞介绍及成因 IIS的短文件名机制，可以暴力猜解短文件名，访问构造的某个存在的短文件名，会返回404，访问构造的某个不存在的短文件名，返回400。 2、漏洞复现 1）、在网站根目录下添加aaaaaaaaaa.html文件 2） 进行猜解 3、漏洞修复 修复方法： 1）升级.net framework 2）修改注册表禁用短文件名功能 快捷键Win+R打开命令窗口，输入regedit打开注册表窗口，找到路径： HKEY_LOCAL_MACHINE\\SYSTEM\\CurrentControlSet\\Control\\FileSystem，将其中的 NtfsDisable8dot3NameCreation这一项的值设为 1，1代表不创建短文件名格式，修改完成后，需要重启系统生效 3）CMD关闭NTFS 8.3文件格式的支持 4）将web文件夹的内容拷贝到另一个位置，如c:\\www到d:\\w,然后删除原文件夹，再重命名d:\\w到c:\\www。 修复后： 4、局限性 \\1) 此漏洞只能确定前6个字符，如果后面的字符太长、包含特殊字符，很难猜解； \\2) 如果文件名本身太短（无短文件名）也是无法猜解的； \\3) 如果文件名前6位带空格，8.3格式的短文件名会补进，和真实文件名不匹配； （三） 远程代码执行1、 漏洞介绍及成因 在IIS6.0处理PROPFIND指令的时候，由于对url的长度没有进行有效的长度控制和检查，导致执行memcpy对虚拟路径进行构造的时候，引发栈溢出，从而导致远程代码执行。 2、 漏洞复现 1）漏洞环境搭建 在windows server 2003 r2 32位上安装iis6.0 2） 触发漏洞 在本地执行exp，exp如下 执行成功后，服务器端弹出计算器： 3、 漏洞修复 1）关闭 WebDAV 服务 2） 使用相关防护设备 （四） 解析漏洞1、 漏洞介绍及成因 IIS 6.0 在处理含有特殊符号的文件路径时会出现逻辑错误，从而造成文件解析漏洞。这一漏洞有两种完全不同的利用方式： 2、漏洞复现 利用方式 1 第一种是新建一个名为 “test.asp” 的目录，该目录中的任何文件都被 IIS 当作 asp 程序执行（特殊符号是 “/” ） 利用方式 2 第二种是上传名为 “test.asp;.jpg” 的文件，虽然该文件真正的后缀名是 “.jpg”, 但由于含有特殊符号 “;” ，仍会被 IIS 当做 asp 程序执行 IIS7.5 文件解析漏洞 URL 中文件后缀是 .php ，便无论该文件是否存在，都直接交给 php 处理，而 php 又默认开启 “cgi.fix_pathinfo”, 会对文件进行 “ 修理 ” ，可谓 “ 修理 ” ？举个例子，当 php 遇到路径 “/aaa.xxx/bbb.yyy” 时，若 “/aaa.xxx/bbb.yyy” 不存在，则会去掉最后的 “bbb.yyy” ，然后判断 “/aaa.xxx” 是否存在，若存在，则把 “/aaa.xxx” 当作文件。 若有文件 test.jpg ，访问时在其后加 /.php ，便可以把 “test.jpg/.php” 交给 php ， php 修理文件路径 “test.jpg/.php” 得到 ”test.jpg” ，该文件存在，便把该文件作为 php 程序执行了。 3、 漏洞修复 1）对新建目录文件名进行过滤，不允许新建包含‘.’的文件 2）曲线网站后台新建目录的功能，不允许新建目录 3）限制上传的脚本执行权限，不允许执行脚本 4）过滤.asp/xm.jpg，通过ISApi组件过滤 三、 Apache漏洞分析（一） Apache简介Apache 是世界使用排名第一的Web 服务器软件。它可以运行在几乎所有广泛使用的 计算机平台上，由于其 跨平台 和安全性被广泛使用，是最流行的Web服务器端软件之一。它快速、可靠并且可通过简单的API扩充，将 Perl/ Python等 解释器编译到服务器中。 （二） 解析漏洞1、 漏洞介绍及成因 Apache文件解析漏洞与用户的配置有密切关系，严格来说属于用户配置问题。 Apache文件解析漏洞涉及到一个解析文件的特性： Apache默认一个文件可以有多个以点分隔的后缀，当右边的后缀无法识别（不在mime.tyoes内），则继续向左识别，当我们请求这样一个文件：shell.xxx.yyy php-&gt;发现后缀是php，交给php处理这个文件 2、 漏洞复现 上传一个后缀名为360的php文件 3、 漏洞修复 将AddHandler application/x-httpd-php .php的配置文件删除。 （三） 目录遍历1、 漏洞介绍及成因 由于配置错误导致的目录遍历 2、 漏洞复现 3、 漏洞修复 修改apache配置文件httpd.conf 找到Options+Indexes+FollowSymLinks +ExecCGI并修改成 Options-Indexes+FollowSymLinks +ExecCGI 并保存； "},{"title":"web渗透详细过程之信息收集篇","date":"2021-08-06T08:58:11.000Z","url":"/2021/08/06/web%E6%B8%97%E9%80%8F%E8%AF%A6%E7%BB%86%E8%BF%87%E7%A8%8B%E4%B9%8B%E4%BF%A1%E6%81%AF%E6%94%B6%E9%9B%86%E7%AF%87/","categories":[["渗透","/categories/%E6%B8%97%E9%80%8F/"]],"content":"Web渗透详细过程之信息收集篇前言在这大千世界中，总有让你心动的目标。当你偶然遇见一位成熟稳重的帅哥，不用我说那内心的小鹿肯定开始乱撞，冰封已久的冰山开始融化。想要把小哥哥追到手，需要一步步来。首先要进行信息收集，需要知道他的个人信息，例如叫什么，联系方式，喜好，在哪里工作，做什么行业，或者家庭住址等等。 收集域名信息通常我们想知道这个心上人叫什么的时候就要想办法得到他的名片，上边一般都会介绍他的姓名，职业，所在单位，单位地址。 在这里对目标进行whois查询，查询域名是否被注册、注册商、DNS。就好比看对方的名片一样。以下介绍几种获取对方名片的方法。 whois查询1、域名whois查询-站长之家  2、IP138网站  3、域名信息查询-腾讯云  4、ICANN LOOKUP  备案信息查询1、SEO综合查询  2、ICP备案查询-站长工具  IP反查站点1、Dnslytics 利用Dnslytics反查IP可以得到如下信息 利用Dnslytics反查域名可以得到如下信息  相关应用信息1、天眼查  2、七麦数据  查找真实IP在一些大的网站都会使用CDN(内容分发网络)，它可以使内容传输的更快、更加稳定。，CDN系统能够实时地根据网络流量和各节点的连接、负载状况以及到用户的距离和响应时间等综合信息将用户的请求重新导向离用户最近的服务节点上。一般CDN隐藏了目标服务器的真实的IP，也提高了安全性。就像你找人家问他的名字，他就告诉你假的名字或外号，这一看对你兴趣不大啊，这时连心上人的真名字都不知道怎嘛进行下一步，那不凉凉了。这里说下如何识别给你的名字是真的还是假的，给假的名字情况下如何获取真实姓名。 如何判断是否使用CDN1、ping目标主域 通过ping目标主域，观察域名解析情况来判断是否使用CDN。 发现使用了CDN。 2、Nslookup 不同DNS解析结果若不一样，很有可能存在CDN服务。 3、ping检测平台 Ping检测-站长工具地址： 绕过CDN常见方法1、ping主域 有的网站只让www域名使用CDN,可以去掉www在ping下。 2、DNS历史查找 CDN可能是在网站上线一段时间后才上线的，可以通过查找域名解析记录的方式去查找真实IP。以下介绍几个平台   3、查询子域名方法 一般都是主站加入CDN，子域名站点很多没有加入，可以通过子域名来获取，下边有收集子域名详细介绍，在这里举例一个。  4、网站邮件头信息 比如说，邮箱注册，邮箱找回密码、RSS邮件订阅等功能场景，通过网站给自己发送邮件，从而让目标主动暴露他们的真实的IP，查看邮件头信息，获取到网站的真实IP。注意：必须是目标自己的邮件服务器，第三方或公共邮件服务器是没有用的。 5、网络空间搜索引擎法 通过关键字或网站域名，就可以找出被收录的IP，很多时候获取到的就是网站的真实IP。 钟馗之眼：：： 6、网站漏洞查找 通过网站的信息泄露如phpinfo泄露，github信息泄露，命令执行等漏洞获取真实ip。 收集子域名之前已经获取地址和姓名了，那就让我们大声把爱说出来。万一和心上人表白失败了，我们不要放弃，毕竟这样不容得到的男人才香啊，之前了解他的工作单位了或者家庭地址了，我们可以从他的同事或者邻居入手，通常这样更容易获取汉子的信息，方便更加深入的了解他。说不定能从同事或者邻居那边美言下，拿下这个高冷的男人了。 在线平台1、IP138  2、站长工具  3、hackertarget  4、phpinfo  5、dnsdumpster  6、zcjun  7、Censys  IP反查绑定域名网站1、chinaz  2、爱站  3、webscan.cc  资产搜索引擎个人常用的有Google、FOFA，也可以使用Shodan、zoomeye钟馗之眼. 1、Google语法 常用语法 2、FOFA语法 可以在首页点击查询语法来查看 工具枚举在这里常用的sublist3r、OneForAll、subDomainsBrute. 1、sublist3r 下载地址: 2、OneForAll 下载地址：运行完成后会生成一个csv文件 3、subDomainsBrute 下载地址： 利用DNS收集常见的DNS记录有以下几类： MX记录： 建立电子邮箱服务，将指向邮件服务器地址，需要设置MX记录。建立邮箱时，一般会根据邮箱服务商提供的MX记录填写此记录。 NS记录： 域名解析服务器记录，如果要将子域名指定某个域名服务器来解析，需要设置NS记录。 SOA记录： SOA叫做起始授权机构记录，NS用于标识多台域名解析服务器，SOA记录用于在众多NS记录中那一台是主服务器。 TXT记录： 可任意填写，可为空。一般做一些验证记录时会使用此项，如：做SPF（反垃圾邮件）记录。 DNS域传送漏洞 1、原理：DNS服务器分为：主服务器、备份服务器和缓存服务器。在主备服务器之间同步数据库，需要使用“DNS域传送”。域传送是指备份服务器从主服务器拷贝数据，并用得到的数据更新自身数据库。 若DNS服务器配置不当，可能导致攻击者获取某个域的所有记录。造成整个网络的拓扑结构泄露给潜在的攻击者，包括一些安全性较低的内部主机，如测试服务器。同时，黑客可以快速的判定出某个特定zone的所有主机，收集域信息，选择攻击目标，找出未使用的IP地址，绕过基于网络的访问控制。2、DNS域传送漏洞检测基本过程 nslookup #进入交互式shell server dns.xx.yy.zz #设定查询将要使用的DNS服务器 ls xx.yy.zz #列出某个域中的所有域名 exit #退出漏洞检测-不存在漏洞 站点信息收集乖乖，现在撩汉子容易吗，咱们接下来在了解下他的爱好，喜欢健身还是喜欢去娱乐场所还是宅在家里，出去玩的话都去哪里玩，喜欢吃什么等等。为咱们下一步攻势做好准备，就不信俘获不到小哥哥的芳心。 判断对方是win还是Linux1、TTL值 可以通过ping来查看，不过不一定非常准可以被修改，默认Linux是64，win是128win： Linux： 2、Nmap 使用命令：nmap -O IP 端口收集nmap CMS指纹识别CMS（内容管理系统）用于网站内容管理，通过识别CMS类型可以查看相应的漏洞拿下站点。如今，网上一些在线的网站查询CMS指纹识别，如下所示：BugScaner: 潮汐指纹：云悉：: 云悉指纹: :  目录扫描1、御剑扫描 2、dirbuster 首先在Target URL输入框中输入要扫描的网址并将扫描过程中的请求方法设置为“Auto Switch(HEAD and GET)”。自行设置线程（太大了容易造成系统死机哦）选择扫描类型，如果使用个人字典扫描，则选择“List based bruteforce”选项。单击“Browse”加载字典。单机“URL Fuzz”，选择URL模糊测试（不选择该选项则使用标准模式）在URL to fuzz里输入“/{dir}”。这里的{dir}是一个变量，用来代表字典中的每一行，运行时{dir}会被字典中的目录替换掉。点击“start”开始扫描 也可以使用kali自带的 3、dirscan 下载地址： 4、dirsearch 下载地址： Google Hacking他基本语法上边有介绍，介绍下典型用法： 查找指定后台地址 查看指定网站的文件上传漏洞 注入页面 目录遍历漏洞 SQL错误 phpinfo() 配置文件泄露 数据库文件泄露 日志文件泄露 备份和历史文件泄露 公开文件泄露 邮箱信息 社工信息 通过用户的一些信息（Mail、Name、ID、Tel）查询用户注册过哪些应用 Github信息泄漏很多网站及系统都会使用pop3和smtp发送来邮件，不少开发者由于安全意识不足会把相关的配置文件信息也放到Github上，所以如果这时候我们动用一下Google搜索语法，就能把这些敏感信息给找出来了。 site:Github.com smtpsite:Github.com smtp @qq.comsite:Github.com smtp @126.comsite:Github.com smtp @163.comsite:Github.com smtp @sina.com.cn 数据库信息泄露： site:Github.com sa passwordsite:Github.com root password 总结要想拿下小哥哥当然要一步步来，前边的信息收集工作是非常重要的。从开始的选择目标，到获取简单的个人信息，如何看对方是否欺骗自己，再到如果拒绝失败从他身边的人下手。可以说能否追求成功这个收集工作起到至关重要的位置。主要是用来新手之间互相交流下经验，老司机可以继续开车了。 参考文档：   "},{"title":"渗透测试基本思路","date":"2021-08-05T07:12:05.000Z","url":"/2021/08/05/%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95%E5%9F%BA%E6%9C%AC%E6%80%9D%E8%B7%AF/","tags":[["信息收集","/tags/%E4%BF%A1%E6%81%AF%E6%94%B6%E9%9B%86/"],["漏洞扫描","/tags/%E6%BC%8F%E6%B4%9E%E6%89%AB%E6%8F%8F/"]],"categories":[["渗透","/categories/%E6%B8%97%E9%80%8F/"]],"content":"​ 有人问我，渗透到底做啥，web渗透到底是干什么，当你拿到一个待检测得站或网站，需要做什么。以我得经验其实web渗透是一个非常简单得事情。今天我就以个人经验来谈一谈怎么去渗透一个网站。 一、信息收集 获取域名的 whois 信息,获取注册者邮箱姓名电话等。 通过站长之家、明小子、k8 等查询服务器旁站以及子域名站点，因为主站一般比较难， 所以先看看旁站有没有通用性的 cms 或者其他漏洞。 通过 DNS 域传送漏洞、备份号查询、SSl 证书、APP、微信公众号、暴力破解、DNS 历史记录、K8 C 段查询、Jsfinder、360 或华为威胁情报、证书序列号获取企业域名与 ip。 通过 Nmap、Wappalyzer、御剑等查看服务器操作系统版本，web 中间件，看看是否存在已知的漏洞，比如 IIS，APACHE,NGINX 的解析漏洞 通过 7KB、破壳扫描网站目录结构，看看是否可以遍历目录，或者敏感文件泄漏，比如php 探针、管理员备份文件。 google hack 进一步探测网站的信息，后台，敏感文件 敏感信息收集，如 github 源码、用 7kb、破壳扫源代码泄露（.hg、.git、cvs、svn、.DS_store 源代码泄露）、google hack、接口信息泄露、社工信息泄露、邮箱地址信息收集、网盘搜索、钟馗之眼、天眼查、威胁情报、微步在线等 通过Wappalyzer、御剑工具对网站指纹识别（包括，cms，cdn，证书等），dns 记录 二、漏洞扫描 用 AWVS、APPSCAN、长亭科技的 Xray 等扫描器检测 Web 漏洞，如 XSS,XSRF,sql 注入，代码执行，命令执行，越权访问，目录读取，任意文件读取，下载，文件包含， 远程命令执行，弱口令，上传，编辑器漏洞，暴力破解等 用 namp、天镜、Nessus、极光等扫描系统 ip，对扫描出来的高危漏洞进行测试，如ms08-067、ms17-010、ms12-020、ms15-035、ms19-0708、永恒之蓝 2 代、cve-2017-7494（samba）、cve-2014-6271(破壳)、php cgi 等相关漏洞验证。 漏洞利用 ​ 利用以上的方式拿到 webshell，或者其他权限 4.权限提升 ​ 提权服务器，比如 windows 下 mysql 的 udf 提权，serv-u 提权，windows 低版本的漏洞， 如 iis6,pr,巴西烤 肉，linux 脏牛漏洞，linux 内核版本漏洞提权，linux 下的 mysql system 提权以及 oracle 低权限提权 5.日志清理 ​ 操作系统、中间件、数据库等日志进行清除 6.总结报告及修复方案"},{"title":"SQL手工注入入门教程","date":"2021-08-03T09:11:01.000Z","url":"/2021/08/03/%E6%B8%97%E9%80%8F%E7%AC%AC%E4%B8%80%E8%AF%BE/","tags":[["sql 注入","/tags/sql-%E6%B3%A8%E5%85%A5/"]],"categories":[["渗透","/categories/%E6%B8%97%E9%80%8F/"]],"content":"mysql基本hack函数：mid SELECT MID(ColumnName, Start [, Length]) FROM TableName LEFT(str,len) 返回字符串str的最左面len个字符 ASCII(str) =ORD 返回字符串str的最左面字符的ASCII代码值。如果str是空字符串，返回0。如果str是NULL，返回NULL SUBSTR(str,pos,len) 从str中多少个字符开始，截取多少位 CAST SELECT CAST(’12’ AS int) 将目标str转化为目标数据类型 IFNULL(expr1,expr2) 如果expr1不是NULL，IFNULL()返回expr1，否则它返回expr2 updatexml() extracavalue() 判断字符的一些语句： LOAD_FILE加载本地文件（服务器上） 说明：“char(99,58,47,98,111,111,116,46,105,110,105)”就是“c:/boot.ini”的 ASCII 代码 说明：“c:/boot.ini”的 16 进制是“0x633a2f626f6f742e696e69” select load_file(‘c:\\wamp\\bin\\mysql\\mysql5.6.17\\my.ini’) into outfile‘c:\\wamp\\www\\test.php’ 可以将其他路径的文件导到web目录来供访问，一般用于把包含一句话木马的文件导出成php来链接 get与post请求注释符的区别一般很容易在各种教程上看到 ‘ or and 1=1 # 或 ‘ or and 1=1 –+ 但可能没人告诉你什么情况下该用什么。 #是sql语句中的注释符，+ 在http请求中表示空格，但get与post中，由于http请求的转义，请求到后端sql语句拼接的时候可能会不一样。 get请求的时候一般用: 1′ and 1=1 –+ //这里最后的空格用+，在请求的时候不会被urlencode，到后端sql语句中就会成为一个正常的空格，– 后面的语句就会被注释。 但是如果在post里最后用加号的话就会被urlencode成%2B，实际的空格被转义才被转义成+ post请求的时候一般用： 这时候，在post的情况下，最后一个空格，可以直接用空格，不用+来代替，因为post参数 空格会自动转成+； 而之所以不在get注入的时候使用“#”来注释，是因为，请求时，“#”不会被urlencode为“%23”，被识别为锚链接，无法传递至sql语句中。 找一个库中有哪些表名： 找一个表中有哪些列名： AND与OR的区别需要理解 and和or的区别 场景举例： 没有订单可以测的情况下，只能用or union联合查询注入当union前面的语句为false时才会执行后面语句（这里一定先学习union查询的用法） 如以下，union语句前 先构建一个错误条件。 union与order by 后面跟着的列数是跟前面的select 列数相同的，不是该表的总列数 总列数判断为： 解释：如果列数为2，则延时5秒响应。 判断某列是否存在也可以用： 当union查同库其他表时，需要知道库名： 如： 读文件/写shell这里包含了网上常见或不常见的导出一句话的骚操作 支持union的方法，最常规的方式： 16进制写shell 其中上面的16 进制组合成的是一个一句话，其实这样的sql可以过waf 利用分隔符写shell 如果不支持union，可以用分隔符导出一句话，当然字段数要大于2。 修改sql日志路径到web下的一个php文件 读文件： 基于布尔值的盲注可以通过响应的不同可以判断sql语句是否正确 枚举字符来判断字符是否存在 mysql的一些特征： 当试探第二个表的时候并不是改为limit1,1，因为limit针对的是条件筛选后的过滤，所以测试其他表的时候，继续修改正则即可，如果us[a-z]为1，ua[a-z]，说明至少有两个表，一个表以us开头，另一个ua开头 标准的正则布尔测试： 比如判断数据库版本： 判断是否条件成立的其他方法： 盲注流程获取库名： and%20ord(substr(database(),1,1))&gt;80+–+ 获取表名： 利用 substr() ascii()函数进行尝试 获取字段名： 获取表数据： 通过dns获取盲注数据： 由于union后必须跟上与前面同样的字段数，所以需要把load_file放在其中，非union直接select load_file即可 dns获取盲注数据示例： \\foobar 后面要有一串任意字符，访问远程目录的意思，所以这个“foobar”可以用任意字符替换。 还可以： 延时注入适用于当我们测试的时候没有任何回显来判断是否有注入，比如订单搜索，比如当sql错误的时候返回与正确的相同，我们就无法通过回显差异来判断注入 如下图代码，成立与否页面不变化 延时注入 适用于当我们测试的时候没有任何回显来判断是否有注入，比如订单搜索，比如当sql错误的时候返回与正确的相同，我们就无法通过回显差异来判断注入 如下图代码，成立与否页面不变化 所以就需要通过判断是否延时来确认是否有注入 如果过滤逗号，可以： 还可以利用 union select 加 order by 逐字猜解… 假设，name 是 admin 当 猜出第一个字母为 ‘a’ 时，’a’=’a’及真。用 0，1表示的话就是1，然后 sleep(15)，如果是假，那就是sleep(05)… 先基本判断有没有延时，然后在load_file来dns查询 可以 post注入最大的区别在于注释符的使用，and改为or而已 如： 参考文章："},{"title":"hello-world","date":"2021-05-02T09:30:00.000Z","url":"/2021/05/02/my-first-blog/","categories":[["日常","/categories/%E6%97%A5%E5%B8%B8/"]],"content":"Hello, World是指在电脑屏幕显示“Hello, World!”（你好，世界！）字符串的计算机程序。相关的程序通常都是每种电脑编程语言最基本、最简单的程序，也会用作示范一个编程语言如何运作。同时它亦可以用来确认一个编程语言的编译器、程序开发环境及运行环境是否已经安装妥当。因为写法简单可见，这也是很多初学者首次接触编程语言时会撰写的程序。 成功啦o(￣▽￣)ブ 有危险Σ(っ °Д °;)っ 有消息(・∀・(・∀・(・∀・*) 当心哦≧ ﹏ ≦ 折叠框的标题 被折叠的内容 1被折叠的内容 2… TYPE是面板框的类型，可以是： successsdangerinfowarning "}]